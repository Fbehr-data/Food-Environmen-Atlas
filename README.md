# Radiant Earth Spot the Crop Challenge

In this project we work on the Zindi challenge: ["Radiant Earth Spot the Crop Challenge"](https://zindi.africa/competitions/radiant-earth-spot-the-crop-challenge/data).

The background of the project:

- "The agricultural sector makes a substantial contribution to GDP and livelihoods across the developing world. However, regular and reliable agricultural data remains difficult and expensive to collect on the ground. As a result, policy-makers usually donâ€™t have access to updated data for implementing policies or supporting farmers." 

- "Earth observation satellites provide a wealth of multi-spectral image data that can be used for developing agricultural monitoring tools. These tools support farmers and policy-makers across Africa and the developing world."

- The dataset was generated by the [Radiant Earth Foundation](https://www.radiant.earth/) team, using the ground reference data collected and provided by the Western Cape Department of Agriculture.

The objective of the project:

- The objective of this challenge is therefore to classify crops in the Western Cape of South Africa using time series of Sentinel-2 multi-spectral data. Our goal was to build a machine learning model to predict the crop type classes for dataset. 

---
## The Team
Anitha Grace:

Felix Behrendt:

Max Langer: 
- I am a biologist and highly motivated to build a career in data science.
- Find me on: [GitHub](https://github.com/langer-net), [LinkedIn](https://www.linkedin.com/in/max-langer-798903127/)

Samuel Kirmeier:

Timo Fischer:

---
## Data Structure
For this project we use 6 of the 12 available spectral bands and the cloud mask of the Sentinel-2 data set. Information on the Sentinel-2 is available [here](https://de.wikipedia.org/wiki/Sentinel-2). 
- Each band consists of 2650 individual tiles (TIF-files), each with a size of 256 x 256 pixels, which corresponds to an area of 2560 m x 2560 m. 
- This means that we have all band information for each unique tile.
- Each of these unique tiles contains a certain amount of fields. 
- Each field has a unique ID and a unique label that identifies the crop type in the field. 

---
## Requirements and Setup:
### Requirements:

- [pyenv](https://github.com/pyenv/pyenv) with Python: 3.9.8
- [Poetry](https://python-poetry.org/): 1.1.13 or higher

### Setup

For setting up the `virtual environment` we used `Poetry`.
So after downloading the repository run the following code in your terminal:

```BASH
pyenv local 3.9.8
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
poetry install
```

This will setup the virtual environment in a `.venv` folder and install all needed packages listed in the `pyproject.toml`. 

### Activate the environment

For activating your virtual environment when restarting the session use the following command:

```BASH
source .venv/bin/activate
```

---
## Downloading and Preprocessing the Data
### Downloading the data
The data is downloaded from the Radiant Earth Foundation servers. This requires the package `radiant-mlhub` in exactly `version 0.1.3`. This package should have already been installed by Poetry. Downloading and extracting may take a while (**about 2 - 5 hours**) depending on your internet connection.
You can start the download by typing the following in the terminal, while `being in the repository-folder`:

```BASH

```
### Preprocessing the data
The preprocessing scripts also take their time. In the `first preprocessing step`, we convert the image information from the TIF-files to NumPy arrays and save one array per field in the .npz format. This step takes another **1 - 3 hours** depending on the processor power in your PC. You can start the conversion by:

```BASH

```

In the `second preprocessing step`, we calculate the mean of for each band of each field for each date. This results in a CSV-file that can be used for further feature engineering. The second preprocessing step is started by:

```BASH

```

---
## Feature engineering, Train-Test-Split and Resampling
### Feature engineering

### Train-Test-Split

### Resampling
